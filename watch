#!/usr/bin/python

# To make this event driven, watch the root window for
# _NET_ACTIVE_WINDOW property changes. The down side of event driven
# is that the window observation may not coincide with the observed
# property change event. (i.e. active window changes twice before we
# can observe window focus once). Also, there's more back and forth
# when windows do switch (prop change event + get_input_focus).

import os
import re
import time
from datetime import datetime, timedelta
from select import select
from subprocess import Popen, PIPE

try:
    from Xlib import display
    winmon_proto = 'xlib'
except: pass
try:
    from osx import something_or_other
    winmon_proto = 'osx'
except: pass
try:
    from win32 import something_or_other
    winmon_proto = 'win32'
except: pass

assert winmon_proto


oldname = newname = ''
oldid = newid = 0L
oldtime = datetime.now()

infds = []
outfds = []
errfds = []

fd_handlers = {}

class WindowEnvironment:

    def winmon_xlib_init()
        self.D = display.Display()

    def winmon_xlib():
        global oldname, newname, oldid, newid, oldtime
        win = self.D.get_input_focus()
        newid = win.focus.id
        newname = win.focus.get_wm_name()
        if newname != oldname or newid != oldid:
            now = datetime.now()
            print "%s %16s %#0.8x %s" % (now.strftime('%s'), (now-oldtime), oldid, oldname)
            oldtime = now
            oldname = newname
            oldid = newid

    def winmon_osx():
        pass

    def winmon_win32():
        pass

    if has_xlib:
        winmon = winmon_xlib

ss_last = None

class ScreenSaver:

    def ss_event(fd):
        global ss_last
        str = fd.readline()
        match = re.match(r'(?P<msg>(BLANK|UNBLANK|LOCK)) (?P<time>.*)', str)
        if match:
            msg = match.groupdict()['msg']
            now = datetime(*time.strptime(match.groupdict()['time'], '%c')[0:6])
            if msg == 'UNBLANK':
                if ss_last:
                    delta = now - ss_last
                else:
                    delta = timedelta()
                print "%s %16s XSCREENSAVER" % (now.strftime('%s'), delta)
                ss_last = None
            else:
                ss_last = now

    def ss_init_xss():
        global ss_proc = Popen(['xscreensaver-command', '-watch'], stdout=PIPE)

fd_handlers[ss_proc.stdout] = ss_event
infds = [ss_proc.stdout]

# This is in a function for profiling purposes
def main():
    winmon()
    running = True
    while running:
        try:
            (infda,outfda,errfda) = select(infds, outfds, errfds, 0.3)
            if infda:
                for fd in infda:
                    fd_handlers[fd](fd)
            # Always check window state
            winmon()
        except KeyboardInterrupt:
            running = False
            # Because otherwise they don't clean up when we go away...
            os.kill(xss_proc.pid, 15)

if __name__ == '__main__':
    main()
